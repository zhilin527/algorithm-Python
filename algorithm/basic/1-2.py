# -*- coding: UTF-8 -*-from heapq import heappush,heappop,nlargest,nsmallestfrom random import randintprint('==========初级6-哈希函数==========')#相同输入相同输出，不同输入均匀分布#1。设计一种RandomPool结构，有如下三个功能：#insert(key)将key插入，不重复加入#delete(key)删除key#getRandom()等概率随机返回任何一个key#要求时间复杂度都是O(1)#用两个hashmap，第一个存key：size，第二个存size：key# hashmap1 key:value# hashmap2 key:value# size表示第几个进来#每insert一个key,hashmap1(key)=size,hashmap2(size)=key,size++#等概率随机取：randomindex = random.randint(0,size),hashmap2(randomindex)# 因为size表示结构中有size个记录，且是从0-size-1。#删除delete key：# delindex = hashmap1(key),# lastindex=size-1,lastkey=hashmap2(lastindex),# size--,# hashmap1(lastkey)=delindex,hashmap2(delindex)=lastkey# del hashmap1(key),del hashmap2(lastindex)# 最后一个补上去class RandomPool():    def __init__(self):        self.d1 = {}        self.d2 = {}        self.size = 0    def insert(self,key):        self.d1[key] = self.size        self.d2[self.size] = key        self.size += 1    def getRandom(self):        return self.d2.get(randint(0,self.size-1))    def delete(self,key):        delindex = self.d1.get(key)        lastindex = self.size-1        lastkey = self.d2.get(lastindex)        self.d1.update({lastkey:delindex})        self.d2.update({delindex:lastkey})        del self.d1[key]        del self.d2[lastindex]#怎么设计多个hash函数，互相独立？#假设给定一个hash函数h，其hashcode结果范围是0～2^64，#将前一半的结果为hash1函数h1，后一半的结果为hash2函数h2;或者直接给两个哈希函数h1h2#h3=h1+1*h2#h4=h1+2*h3#...#布隆过滤器#100亿个url黑名单，给一个url，判断在不在黑名单中，#数组，假设有1000大小，比特个数就是1000*4*8，假设给定一个数组有m个bit位#给一个url，经过hash函数得到code，code%m,将对应的bit位置为1，若设计K个hash函数，一个url就将K个bit位置1#将100亿个url全部hash完，得到数组。#给定一个url，经过K个hash函数，得到K个位置的bit位，若K个bit位全部为1，表示命中黑名单；否则不命中#bit个数m=(n*lnP)/(ln2)^2,n是样本量，P是0.00001#hash函数个数K=ln2*(m/n)=0.7*(m/n)#实际失误率=(1-e^-((n*K)/m))^K#一致性哈希#解决服务器负载均衡的问题#假设要通过一个key寻找一个value，后台服务器有3台，m1，m2，m3#假设负载均衡的hash函数值是一个环，Hash值从0～2^64#m1m2m3的host通过hash函数得到3个值m1m2m3，进行排序存到每台主机[m1,m2,m3]，# 假设要查找key=zuo的value值，key=zuo通过hash函数得到其哈希值k，在数组中二分查找k，找到k>=m的第一个m#随后在m主机上查找key=zuo的value值#最大的问题是：主机较少时，不能均匀分配全部的Hash值，假设Hash值从0～2^64，有可能m1m2挨得比较近#解决方法是：虚拟节点，# 物理机器m1：m1-1，m1-2，。。。等虚拟节点；物理机器m2：m2-1，m2-2。。。等虚拟节点#维护一张路由表，m1：m1-1，m1-2，。。。等虚拟节点；m2：m2-1，m2-2。。。等虚拟节点#这些虚拟节点通过hash函数随机打在hash值环上，前台请求通过hash函数找到的hash值映射到虚拟节点上，通过虚拟节点# 找物理主机，# 扩容：修改路由表，将部分虚拟节点转移到新物理主机上。print('==========初级7-并查集==========')#并查集，太难了# 解决的问题：1。检查两个元素是否属于一个集合；2。两个元素各自在的集合合并## 代表节点，一个集合第一个指向其自己的节点class Node():    def __init__(self,v):        self.value = vclass UnionFindSet():    def __init__(self):        self.fatherMap = {}        self.sizeMap = {}    #传入节点列表，构造其初始并查集网    def makeSets(self,nodes):        self.fatherMap.clear()        self.sizeMap.clear()        for node in nodes:            self.fatherMap.update({node:node})            self.sizeMap.update({node:1})    #传入一个节点，返回其代表节点    def findHead(self,node):        father = self.fatherMap.get(node)        if father is not node:            father = self.findHead(father)        self.fatherMap.update({node:father})        return father    #传入两个节点，返回其代表节点是否相同    def isSameSet(self,a,b):        return self.findHead(a) == self.findHead(b)    #并    def union(self,a,b):        if a == None or b == None:            return        aHead = self.findHead(a)        bHead = self.findHead(b)        if aHead != bHead:            aSetSize = self.sizeMap.get(aHead)            bSetSize = self.sizeMap.get(bHead)            if aSetSize <= bSetSize:                self.fatherMap.update({aHead:bHead})                self.sizeMap.update({bHead:bSetSize+aSetSize})            else:                self.fatherMap.update({bHead:aHead})                self.sizeMap.update({aHead:aSetSize+bSetSize})print('==========初级7-前缀树==========')class TrieNode:    def __init__(self):        self.path = 0 #经过该节点次数        self.end = 0 #以该节点结尾的次数        self.nexts = [None for i in range(26)]# TrieNode[] nexts        #这个节点有26条路class Trie():    def __init__(self,root=None):        self.root = TrieNode()    def insert(self,word):        if word == None:            return        charArray = [w for w in word]        node = self.root        index = 0        for w in charArray:            index = ord(w) - ord('a')            if node.nexts[index]==None:                node.nexts[index] = TrieNode() #没有该节点，则创建            node = node.nexts[index] #有该节点直接拿出来，26种index对应26种node，            node.path += 1        node.end += 1    def delete(self,word):        if self.search(word)!=0:            charArray = [w for w in word]            node = self.root            index = 0            for w in charArray:                index = ord(w) - ord('a')                if (node.nexts[index].path - 1 == 0):                    node.nexts[index] = None                    return #node.nexts[index]就表示当前节点，根据index区分是26种中哪一种node                # 如果当前节点node.path-1==0，表示没有经过该节点的了，直接置为None，后面的都不要了                node = node.nexts[index]            node.end -= 1    def search(self,word):        if word == None:            return 0        charArray = [w for w in word]        node = self.root        index = 0        for w in charArray:            index = ord(w) - ord('a')            if node.nexts[index]==None:                return 0            node = node.nexts[index]        return node.end    def prefixNumber(self,pre): #经过次数        if pre==None:            return 0        charArray = [w for w in pre]        node = self.root        index = 0        for w in charArray:            index = ord(w) - ord('a')            if node.nexts[index] == None:                return 0            node = node.nexts[index]        return node.pathprint('==========初级8-IPO==========')class Code_Less_money():    def __init__(self):        pass    def lessMoney(arr):        item = []        sum = 0        cur = 0        for i in arr:            heappush(item,i)        while len(item) > 1:            cur = heappop(item) + heappop(item)            sum = sum + cur            heappush(item,sum)        return sumclass Code_IPO():    class Node():        def __init__(self,p=0,c=0):            self.p = p            self.c = c        def __lt__(self, other):            return self.c < other.c    def findMaximizedCapital(k,w,Profits,Capital):        if w >= max(Capital):            return w + sum(nlargest(k,Profits))        projects = [(Capital[i],Profits[i]) for i in range(len(Capital))]        available = []        projects.sort(key=lambda x:-x[0])        while k>0:            while projects and projects[-1][0] <= w:                heappush(available,-projects.pop()[1])            if not available:                break;            w+=-heappop(available)            k-=1        return w#打印字符串的全排列if __name__ == '__main__':    # arr = [10,20,30]    # print(Code_Less_money.lessMoney(arr))    # def jien(n):    #     if n == 1:    #         return 1    #     else:    #         return n * jien(n-1)    # print(jien(4))    r = RandomPool()    r.insert('a')    r.insert('b')    r.insert('c')    r.insert('d')    print(r.getRandom())    r.delete('c')    r.insert('e')    print(r.d1)    print(r.d2)