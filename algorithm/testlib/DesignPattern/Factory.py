# -*- coding: UTF-8 -*-# 简单工厂# 定义产品工厂类，在产品工厂类中代码根据业务逻辑去产生不同的产品# 简单，缺点是新增加产品，需要修改工厂产品类的逻辑代码，不符合开放封闭原则# 工厂方法# 定义产品接口，然后根据不同产品的继承关系，定义不同产品的工厂类去实现接口，由子类工厂决定实例化哪个类# 符合开放封闭原则，但是代码量较大。## 抽象工厂# 定义抽象工厂接口，不同的产品族去实现接口，由产品族工厂类产生实例化对象。# 优缺点，新增产品族方便；但是新增一个产品麻烦，要在不同的产品族中都要添加class Food():    def printName(self):        passclass Weapon():    def shoot(self):        passclass Vehicle():    def go(self):        passclass AbstractFactory():    def createFood(self):        pass    def createVehicle(self):        pass    def createWeapon(self):        passclass AK47(Weapon):    def shoot(self):        print('tututututu.....')class Bread(Food):    def printName(self):        print('wdm')class Broom(Vehicle):    def go(self):        print('boom wwuwuuwuw...')class Car(Vehicle):    def go(self):        print('Car go wuwuwu...')class MagicStick(Weapon):    def shoot(self):        print('diandiandian.....')class MushRoom(Food):    def printName(self):        print('dmg')class ModernFactory(AbstractFactory):    def createFood(self):        return Bread()    def createVehicle(self):        return Car()    def createWeapon(self):        return AK47()class MagicFactory(AbstractFactory):    def createFood(self):        return MushRoom()    def createWeapon(self):        return MagicStick()    def createVehicle(self):        return Broom()if __name__ == '__main__':    #现代人    man1 = ModernFactory()    food1 = man1.createFood()    food1.printName()    weapon1 = man1.createWeapon()    weapon1.shoot()    vehicle1 = man1.createVehicle()    vehicle1.go()    #魔法人    man2 = MagicFactory()    food2 = man2.createFood()    food2.printName()    weapon2 = man2.createWeapon()    weapon2.shoot()    vehicle2 = man2.createVehicle()    vehicle2.go()