# -*- coding: UTF-8 -*-# 装饰器的应用：# 1.权限验证# 2.添加日志# 装饰器装饰函数后，函数名等函数属性会发生改变;而用wraps装饰装饰器后，装饰器则不会改变函数的函数名和属性#from functools import wrapsdef my_decorator(func):    def wrapper(*args,**kwargs):        '''decorator'''        print('calling decorated function')        return func(*args,**kwargs)    return wrapper@my_decoratordef example():    '''Docstring'''    print('Called example function')def my_decorator2(func):    @wraps(func)    def wrapper(*args,**kwargs):        '''decorator'''        print('calling decorated function')        return func(*args, **kwargs)    return  wrapper@my_decorator2def example2():    '''Docstring'''    print('called example function')# 1.权限验证def login_check(func):    '''Decorator'''    @wraps(func)    def wrapper(*args,**kwargs):        if args[0].stat != 'login':            print('Please login first.')        else:            return func(*args,**kwargs)    return wrapperclass Visitor(object):    def __init__(self,stat):        self.stat = stat    @login_check    def acess_2_resourse(self):        print('start downloading')# 2.添加日志def with_log(func):    @wraps(func)    def wrapper(*args,**kwargs):        log_string = func.__name__ + ' was called. ' + 'params: {0},{1} '.format(*args,**kwargs)        print(log_string)        return func(*args,**kwargs)    return wrapper# 装饰器本身带参数def logit(log_file='./out.log'):    def with_log_decorator(func):        @wraps(func)        def wrapper(*args,**kwargs):            log_string = func.__name__ + ' was called. ' + 'params: {0},{1} '.format(*args,**kwargs)            print('Here->',log_string)            with open(log_file,'a') as f:                f.write(log_string + '\n')            return func(*args,**kwargs)        return wrapper    return  with_log_decoratorclass Add(object):    def __init__(self):        self.name = 'add'    @with_log    def a_b(self, a, b):        return a + b@logit('./out.log')def a_b_2(a, b):    return a + b# 类做装饰器，1。类装饰器可以把装饰器本身的参数封装在类中，从而不用最外层闭包；# 2。类装饰器还可以定义一些后续函数，在被装饰的函数之后执行，代码维护起来更方便class logit2(object):    def __init__(self,log_file = 'out.log'):        self.log_file = log_file    def __call__(self,func):        @wraps(func)        def wrapper(*args,**kwargs):            log_string = func.__name__ + ' was called. '            print(log_string)            with open(self.log_file,'a') as f:#1                f.write(log_string + '\n')            self.notify()#2            return func(*args,**kwargs)        return wrapper    def notify(self):        passclass email_logit(logit2):    def __init__(self,email = '1031890317@qq.com',*args,**kwargs):        self.email = email        super(email_logit,self).__init__(*args,**kwargs)    def notify(self):        # 发email模块代码        pass@logit2('./out.log')def a_b_3(a, b):    return a + bif __name__ == '__main__':    # print(example.__name__,example.__doc__)    # print(example2.__name__,example2.__doc__)    # # example()    # # example2()    # visit = Visitor('login')    # visit.acess_2_resourse()    # visit.stat = 'downloading'    # visit.acess_2_resourse()    # add = Add()    # print(add.a_b(1,2))    # print(a_b_2(2,3))    print(a_b_3(1,2))