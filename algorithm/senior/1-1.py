# -*- coding: UTF-8 -*-from collections import dequeprint('1.进阶1-kmp字符串匹配')def getIndexOf(s,m):    '''    :param s:    :param m:    :return: 求在S中能否匹配到M，若匹配到，则返回匹配到的S中第一个下标；    '''    if not s or not m or len(m)<1 or len(s) < len(m):        return -1    str1 = list(s)    str2 = list(m)    i1,i2 = 0,0    next_s = getNextArray(str2)    while i1 < len(str1) and i2 < len(str2):        if str1[i1] == str2[i2]:            i1 += 1            i2 += 1        elif next_s[i2] == -1:            i1 += 1        else:            i2 = next_s[i2]    return (i1-i2) if i2 == len(str2) else -1def getNextArray(str2):    '''    :param str2:    :return: 返回一个列表，列表中每个元素代表当前位置之前的所有元素中，最长前缀和最长后缀匹配时的长度。    '''    if len(str2) == 1:        return [-1]    next_s = [0 for i in range(len(str2))]    next_s[0]=-1    next_s[1]=0    i,cn=2,0    while i<len(next_s):        #当前元素上一个元素，如果与跳转元素cn等，则当前元素的next_m值next_m[i]=next_m[i-1]+1        if str2[i-1] == str2[cn]:            next_s[i] = cn+1            cn+=1            i+=1        elif cn>0:            #如果与跳转元素cn不等，cn继续跳            cn = next_s[cn]        else:            #若cn不>0了，next_m[i]=0            next_s[i] = 0            i+=1    return next_sprint('2.进阶2-BFPRT topK算法问题')#快排partition#bfprt 1.逻辑分组,5个数一组，分成N/5组；2.每个小组内排序；3.每个组的中位数拿出来，N/5个；# 4.new array N/5递归调用bfprt算法，bfprt(new_array,len(new_array)/2)中位数数组的中位数num# 5.中位数num作为划分界限进行partitiondef partition(arr,l,r,v):    less = l-1    more = r+1    cur = l    while cur < more:        if arr[cur] < v:            arr[cur],arr[less+1] = arr[less+1],arr[cur]            less += 1            cur += 1        elif arr[cur] > v:            arr[cur],arr[more-1] = arr[more-1],arr[cur]            more -= 1        else:            cur += 1    return less+1def pivot_median(arr):    n = len(arr)    while n > 5:        cols = n//5        m = []        for i in range(cols):            cur = sorted(arr[i*5:i*5+5])            m.append(cur[2])        arr = m        n = len(arr)    arr.sort()    return arr[n//2]def bfprt(arr, k):    pivot = pivot_median(arr)    # pivotIndex = arr.index(pivot)    index = partition(arr,0,len(arr)-1,pivot)    n = len(arr)    if k < n - index:        return bfprt(arr[index + 1:n], k)    elif k == n - index:        return pivot    elif k > n - index:        return bfprt(arr[0:index], k - (n - index))def getmaxK(arr,k):    themaxk = bfprt(arr,k)    res=[]    for num in arr:        if num >= themaxk:            res.append(num)    return resdef getminK(arr,k):    maxk = len(arr)-k    themaxk = bfprt(arr, maxk)    res=[]    for num in arr:        if num < themaxk:            res.append(num)    return resprint('3.进阶2-生成窗口最大值数组')#固定长度3的窗口走一遍列表，求每一次的窗口最大值#双端队列dequedef getMaxWindow(arr,w):    if not arr or w < 1 or w > len(arr):        return []    qmax = deque()    # index = 0    res = []#窗口最大值结果数组    for i in range(len(arr)):        #更新deque，存储下标；窗口w右边界增加的情况        # 队列不为空，且当前元素 大于等于 队尾元素        while qmax and arr[i] >= arr[qmax[-1]]:            qmax.pop()#队尾元素弹出        qmax.append(i)#队列为空或者当前元素小于队尾元素，当前下标进队列        #窗口左边界减，i-w下标已过期，看是不是在队首，在就剔除过期的下标。        if i-w == qmax[0]:            qmax.popleft()        #窗口已经形成，窗口的左边界下标是i-w+1        if i>=w-1:#i-w+1>=0            res.append(arr[qmax[0]])    return resprint('4.进阶2-窗口最大值，窗口最小值，差值<=num的子数组个数')#结论：1。某一个范围内，max-min<=num满足，那么范围再小时，也一定满足#2。某一个范围内，max-min<=num不满足时，那么范围再大时，也一定不满足#L，R两个指针，res=0，初始值=0，R往右进，更新最大值max数组，最小值min数组；#直到遇到第一个R，其后R+1位置不满足max-min<=num，则res+=R+1，之后，L++，R++继续往后def solution4(arr,num):    qmax = deque()    qmin = deque()    L,R = 0,0    res = 0    while L < len(arr):        while R < len(arr):            while qmax and arr[R] >= arr[qmax[-1]]:                qmax.pop()            qmax.append(R)            while qmin and arr[R] <= arr[qmin[-1]]:                qmin.pop()            qmin.append(R)            if arr[qmax[0]] - arr[qmin[0]] > num:                break            R += 1        if qmax[0] == L:            qmax.popleft()        if qmin[0] == L:            qmin.popleft()        res += R-L        L += 1    return resprint('5.进阶2-单调栈')#解决的问题是，在一个数组中，对于每一个数，找到左边最近的比他大的，右边最近的比他大的。#单调栈，栈底至顶，由大到小进，遇到不符合单调栈不能进的元素则弹出；#弹出元素为当前元素，迫使当前元素弹出的元素是右边最近最大的，栈中弹出元素下一个为左边最近最大的#栈中已有元素弹完了，迫使元素进栈，继续；数组空了，则栈依次弹出，右边最近最大为空，左边最近最大为栈中下一个元素# 右边最近比他大的def solution5(arr): # [4,2,3,5,7,6,9]    if not arr:        return []    res = [0 for _ in range(len(arr))]    s = [] # s[i]表示当前i位置元素右边最近比他大的元素下标    index = 0    while index < len(arr):        if s and arr[index] > arr[s[-1]]:            res[s.pop()] = arr[index]        else:            s.append(index)            index += 1    if s:        res[s.pop()] = None    return res# 左边最近比他大的def solution5l(arr):    if not arr:        return []    s=[]    res=[0 for _ in range(len(arr))]    index = len(arr)-1    while index >= 0:        if s and arr[index] > arr[s[-1]]:            res[s.pop()] = arr[index]        else:            s.append(index)            index -= 1    if s:        res[s.pop()] = None    return resprint('6.进阶3-1-构造数组的MaxTree')# 二叉树的结构：# public class Node {#     public int value;#     public Node left;#     public Node right;#     public Node (int data){#         this.value = data;#     }# }# MaxTree 定义：#     数组中没有重复元素#     MaxTree是一颗二叉树，数组中每一个值对应一个二叉树节点#     包括MaxTree在内及任意子树，值最大的节点都是树的头#     有重复元素的数组arr，写出生成这个数组的MaxTree函数，要求时间复杂度o(N)# 解法# 1.建大根堆过程O(N)# 2.单调栈，1。一个数组，对于每一个数，找到左边最近最大的，右边最近最大的#  2。5，null，6情况。节点5挂在节点6下；5，7，6情况，节点5挂在6下(左右最近最大中较小的)#   5，null，null情况，节点5作为头节点def getMaxTree(arr):    passprint('7.进阶3-1-求最大子矩阵的大小')# 给定一个整型矩阵，其中的值只有0，1，求其中全是1的所有矩形区域中，最大的矩形区域为1的数量# 例如1 1 1 0其中最大的矩形区域有3个1，返回3# 再例如# 1 0 1 1# 1 1 1 1# 1 1 1 0# 其中最大的矩形区域有6个1，返回6if __name__ == '__main__':    # arr=[7,2,4]    # w=2    # print(getMaxWindow(arr,w))    arr1 = [4,2,3,5,7,6,6,9,10,15,11,13,12]    arr2 = [9,6,7,5,3,2,4,1]    # print(solution5(arr1))    # print(mergeSort(arr1,0,len(arr1)-1))    # print(arr1)    # quickSort(arr2,0,len(arr2)-1)    # print(arr2)    # print(bfprt(arr1,2))    # print(arr1)    # print(getminK(arr1,2))    # print(pivot_median(arr2))    # print(arr2)    # mergeSort(arr1,0,len(arr1)-1)    print(arr1)    pass