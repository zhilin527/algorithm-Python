# -*- coding: UTF-8 -*-import threadingfrom concurrent.futures import ThreadPoolExecutorimport timeimport random# CPU密集型和IO密集型，串行和多线程print('#-----------------------------------------------------------')N = 4pool = ThreadPoolExecutor(max_workers = N)# IO密集型操作def io_bound_func(x):    time.sleep(x)    print('Sleep for %d seconds.'% x)# 串行def process_array(arr):    for x in arr:        io_bound_func(x)# 线程池def fast_process_array(arr):    for res in pool.map(io_bound_func,arr):        print("In main , res is {0}".format(res))def time_it(fn,*args):    start = time.time()    fn(*args)    print('%s版本运行时间为 %s.5f 秒。'%(fn.__name__,time.time()-start))# 串行化时间# time_it(process_array,[1,2,3])# pool# time_it(fast_process_array,[1,2,3])# cpu密集型def cpu_bound_func(x):    tot = 0    a = 1    while a<=x:        tot+=x        a+=1        print('Finish sum from 1 to %d.'%x)        return tot# 串行def process_array2(arr):    for x in arr:        cpu_bound_func(x)# 线程池def fast_process_array2(arr):    for res in pool.map(cpu_bound_func,arr):        print("In main , res is {0} ".format(res))# time_it(process_array2,[10000,10000,10000])# time_it(fast_process_array2,[10000,10000,10000])# 多线程同时修改同一数据，不设锁，当次数足够大时，最终结果<理论预期值print('#-----------------------------------------------------------')def desc_func(l):    for _ in range(10):        l += 1        print(l)def f1(l):    t1 = threading.Thread(target=desc_func,args = (l,))    t2 = threading.Thread(target=desc_func,args = (l,))    t1.start()    t2.start()    t1.join()    t2.join()# 多线程Lock和Semaphoreprint('#-----------------------------------------------------------')class myThreadLock(threading.Thread):    def __init__(self,lock,theadName):        super().__init__(name=theadName)        self.lock = lock    def run(self):        global count        self.lock.acquire()        for i in range(5):            count += 1            time.sleep(0.5)            print(self.getName(),count)        self.lock.release()count = 0# threads = []# lock1 = threading.Lock()# for i in range(3):#     threads.append(myThreadLock(lock1,'Thread-'+str(i)))# for t in threads:#     t.start()# for t in threads:#     t.join()class SemThread(threading.Thread):    def __init__(self,Semaphore,theadName):        super().__init__(name=theadName)        self.sem = Semaphore    def run(self):        print('{0} is waiting semaphore.'.format(self.name))        self.sem.acquire()        print('{0} acquired semaphore({1}).'.format(self.name, time.ctime()))        time.sleep(5)        print('{0} release semaphore.'.format(self.name))        self.sem.release()threads = []sem = threading.Semaphore(3)for i in range(4):    threads.append(SemThread(sem,'Thread-'+str(i)))for t in threads:    t.start()for t in threads:    t.join()if __name__ == '__main__':    pass