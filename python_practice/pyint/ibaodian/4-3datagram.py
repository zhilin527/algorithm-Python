#链表，队列，栈，二叉树，堆#链表#1。反转链表class ListNode:    '''    定义节点类    data:数据    next:下一个数据    '''    def __init__(self,data,next = None):        self.data = data        self.next = next    def __repr__(self):        '''        用来定义Node的字节输出        '''        return str(self.data)class ChainTable(ListNode):    '''    定义链表    '''    def __init__(self):        self.head = None        self.length = 0    def isEmpty(self):        return (self.length == 0)    def add(self, dataOrNode):        item = None        if isinstance(dataOrNode, ListNode):            item = dataOrNode        else:            item = ListNode(dataOrNode)        if not self.head:  # 若链表的头为空            self.head = item            self.length += 1        else:            node = self.head            while node.next:  # 当有节点时，新增下一个节点                node = node.next            node.next = item            self.length += 1    def delete(self, index):        if self.isEmpty():            print("链表是空的")            return        if index < 0 or index >= self.length:            print("超出索引长度")            return        # 删除第一个节点        if index == 0:            self.head = self.head.next            self.length -= 1            return        # prev为保存前导节点        # node为保存当前节点        # 当j与index相等时就        # 相当于找到要删除的节点        j = 0        node = self.head        prev = self.head        while node.next and j < index:            prev = node            node = node.next            j += 1        if j == index:  # 找到节点后将下一个节点覆盖到本节点            prev.next = node.next            self.length -= 1    def update(self, index, data):        if self.isEmpty() or index < 0 or index >= self.length:            print('超出索引长度')            return        j = 0        node = self.head        while node.next and j < index:            node = node.next            j += 1        if j == index:            node.data = data        # 查找一个节点    def getItem(self, index):        if self.isEmpty() or index < 0 or index >= self.length:            print('超出索引长度')            return        j = 0        node = self.head        while node.next and j < index:            node = node.next            j += 1        return node.data        # 从头到尾打印链表    def print_chain(self):        if self.isEmpty():            print('链表为空')        num = []        node = self.head        while node:            num.append(node)            node = node.next        return num        # 查找一个节点的索引    def getIndex(self, data):        j = 0        if self.isEmpty():            print('链表为空')            return        node = self.head        while node:            if node.data == data:                return j            node = node.next            j += 1        if j == self.length:            print("%s not found" % str(data))            return    def insert(self, index, dataOrNode):        if self.isEmpty():            print('链表为空')            return        if index < 0 or index >= self.length:            print('超出索引长度')            return        item = None        if isinstance(dataOrNode, ListNode):            item = dataOrNode        else:            item = ListNode(dataOrNode)        if index == 0:            item.next = self.head            self.head = item            self.length += 1            return        j = 0        node = self.head        prev = self.head        while node.next and j < index:            prev = node            node = node.next            j += 1        if j == index:            item.next = node            prev.next = item            self.length += 1    def clear(self):        self.head = None        self.length = 0    def __repr__(self):        if self.isEmpty():            return "链表为空"        node = self.head        nlist = ''        while node:            nlist += str(node.data) + ' '            node = node.next        return nlist    def __getitem__(self, ind):        if self.isEmpty() or ind < 0 or ind >= self.length:            print("超出索引长度")            return        return self.getItem(ind)    def __setitem__(self, ind, val):        if self.isEmpty() or ind < 0 or ind >= self.length:            print("超出索引长度")            return        self.update(ind, val)    def __len__(self):        return self.length    def reverse(self):        '''        :param self:        :param head:        :return:        '''        if self.isEmpty():            print("链表是空的")            return -1        pre = None        cur = self.head        while cur:            nextnode = cur.next            cur.next = pre            pre = cur            cur = nextnode        self.head = preclass Solution:    @staticmethod    def reverseList(head):        '''        :param self:        :param head:        :return:        '''        pre = None        cur = head        while cur:            nextnode = cur.next            cur.next = pre            pre = cur            cur = nextnode        return predef test_reverse():    ll=[1,2,3,4,5]    chaintable = ChainTable()    for i in ll:        chaintable.add(i)    print(chaintable)    chaintable.reverse()    print(chaintable)test_reverse()print('##############队列###############')from collections import dequeclass Queue(object):    def __init__(self):        self.items = deque()        # self.minList = [] #当前栈元素从小到大存    def append(self,val):        return self.items.append(val)    def pop(self):        return self.items.popleft()    def isEmpty(self):        return len(self.items) == 0    def __str__(self):        return str(self.items)def test_queue():    q = Queue()    q.append(3)test_queue()print('##############栈###############')class Stack():    def __init__(self):        self.items = deque()        self.minList = [] #当前栈元素从大到小存    def push(self,val):        if not self.minList:            self.minList.append(val)        else:            if val < self.minList[-1]:                self.minList.append(val)            else:                self.minList.append(self.minList[-1])        return self.items.append(val)    def pop(self):        self.minList.pop()        return self.items.pop()    def isEmpty(self):        return len(self.items)==0    def __str__(self):        return str(self.items)    def getMin(self):        return self.minList[-1]def test_stack():    stack = Stack()    stack.push(1)    stack.push(2)    stack.push(3)    print(stack.pop())    print(stack.pop())    print(stack.pop())test_stack()print('##############两个栈实现队列###############')class Queue_on_Stack():    def __init__(self):        self.stack1 = Stack()        self.stack2 = Stack()    def append(self,val):        self.stack1.push(val)    def pop(self):        while not self.stack1.isEmpty():            self.stack2.push(self.stack1.pop())        result = self.stack2.pop()        while not self.stack2.isEmpty():            self.stack1.push(self.stack2.pop())        return result    def isEmpty(self):        return self.stack1.isEmpty()def test_queue_on_stack():    q2 = Queue_on_Stack()    q2.append(1)    q2.append(2)    q2.append(3)    print(q2.pop())    print(q2.pop())    print(q2.pop())test_queue_on_stack()print('###############topk##############')###########hash冲突的解决办法#1。开放地址法，冲突之后根据另一种方法来寻找下一个可用的槽位；线性探测，二次探测，双函数探测#2。链地址法，元素key冲突之后，使用链表填充相同key的元素#二叉树#堆#topk#import heapqclass TopK():    '''    获取大量元素的topK个大元素，固定内存    思路：    1.先放入元素前k个建立一个最小堆    2.迭代剩余元素：        如果当前元素小于堆顶元素，直接pass        否则替换堆顶元素为当前元素，并重新调整堆    '''    def __init__(self,iterable,k):        self.minheap = []        self.capacity = k        self.iterable = iterable    def push(self,val):        if len(self.minheap) < self.capacity:            heapq.heappush(self.minheap,val)        else:            if val < self.minheap[0]:                pass            else:                heapq.heapreplace(self.minheap,val)    def get_top(self):        for val in self.iterable:            self.push(val)        return self.minheapdef test_topk():    import random    ll = list(range(100))    random.shuffle(ll)    topk = TopK(ll,10)    print(topk.get_top())test_topk()