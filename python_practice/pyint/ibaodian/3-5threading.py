#GIL# 什么是CPython GIL#GIL global Interpreter Lock#1。CPython解释器的内存管理并不是线程安全的#2。保护多线程情况下对Python对象的访问#3。CPython使用简单的锁机制避免多个线程同事执行字节码#GIL的影响#1。同一时间只能有一个线程执行字节码#2。CPU密集型的程序难以利用多核优势#3。IO期间会释放GIL，对IO密集程序影响不大#区分CPU密集和IO密集#1。CPU密集可以使用多线程+进城池#2。IO密集使用多线程/协程#3。cython扩展import threadinglock = threading.Lock()n = [0]def foo():    with lock:        n[0] = n[0] + 1        n[0] = n[0] + 1threads = []for i in range(100):    t = threading.Thread(target=foo)    threads.append(t)for i in threads:    t.start()print(n)#执行多次，n多数情况是10000；有时会是9998，不满10000；#因为python不是线程安全的，多个线程同一时间操作同一内存区域#有了GIL为什么还要关注线程安全#Python中什么操作才是原子的？一步到位执行完#1。一个操作如果是一个字节码指令可以完成，就是原子的#2。原子的操作是可以保证线程安全的,非原子操作不是线程安全的#3。使用dis操作来分析字节码#如何剖析程序性能#使用各种profile工具#1。二八定律，大部分时间耗时在少量代码上#2。内置的profile/cprofile等工具#3。使用pyflame(uber开源)的火焰图工具