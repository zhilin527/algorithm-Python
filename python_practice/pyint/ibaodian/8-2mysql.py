#索引及优化#什么是索引？#索引是数据表中一个或者多个列进行排序的数据结构#索引能够大幅提升检索速度#什么是B-Tree？#查找结构进化史#1。线性查找。实现简单；慢；#2。二分查找。简单；要求有序，插入很慢#3。哈希。查询快；占用空间，不太适合大规模数据#4。二叉查找树bst，插入和查询很快；无法村大规模数据，复杂度退化，插入有序节点时会成线性结构，复杂度就退化了#5。平衡二叉树，解决了复杂度退化，树是平衡的;节点非常多的时候，依然树很高很高#6。多路查找树：一个父亲多个孩子节点（度），节点过多，树高不会特别深#7。多路平衡查找树->>B-Tree#多路平衡查找树#1。多路平衡查找树，每个节点最多m，m>=2个孩子节点，成为m阶或度#2。叶子节点具有相同的深度#3。节点中的数据key从左到右是递增的#4。节点中存孩子节点，又存记录，不能实现范围查找#Mysql数据库引擎实际上是B+ Tree，是B树的变形#1。只在叶子节点带有指向记录的指针，为什么？可以增加树的度数，非叶子节点可以存更多的孩子节点，从而增加度#2。叶子节点通过指针相连，为什么？可以实现范围查找##那是不是非叶子节点孩子节点越多越好呢？度数越高越好呢？# 不是的，孩子节点数目是跟操作系统磁盘块大小相关的，是由操作系统决定的##Mysql索引类型#1。普通索引create index#2。唯一索引 create unique index#3。多列索引#4。主键索引 primary key，一个表只能有一个#5。全文索引，fulltext index，innoDB不支持#什么时候创建索引？#建表的时候需要根据查询需求来创建索引#1。经常用作查询条件的字段 where条件#2。经常用作表链接的字段#3。经常出现在order by，group by之后的字段##创建索引有哪些需要注意的事项#1。非空字段 NOT NULL，要设置默认值#2。区分度高，离散度大，作为索引的字段尽量不要大量相同#3。索引的长度不要太长，比较耗费时间，很多primary key都用int，因为简单快##索引什么时候失效？#1。模糊匹配，以%开头的like语句，模糊搜索#2。类型隐转，python传字段的时候，类型不匹配#3。最左匹配，没有满足最左前缀原则，想想为什么是最左匹配呢？从左边开始比较#其实就是Mysql的B+树的key没有办法直接去比较的时候，索引就会失效#什么是聚集索引？非聚集索引？#聚集索引和非聚集索引指的是叶子节点存的是指针还是数据记录。。#MyISAM索引和数据分离，使用的是非聚集索引#InnoDB数据文件就是索引文件，主键索引就是聚集索引#*# A：id  val    B： id   val#    1   ab        1     ab#    2   a         3     b## *##内链接：select A.id as a_id,B.id as b_id,A.val as a_val,B.val as a_val# from A inner join B on A.id=B.id;#当两个表都匹配时，才返回匹配行#外连接：左连接，右连接。左连接返回左表中所有数据，即使右表中没有记录#没有匹配到的字段会被设置成NULL#左连接： a_id    b_id    a_val    b_val#         1       1       ab       ab#         2      NULL     a       NULL#select A.id as a_id,B.id as b_id,A.val as a_val,B.val as b_val from A right join B on A.id=B.id#         1       1      ab        ab#        NULL     3     NULL       ab#全连接：OUTER FULL JOIN只要有一个表存在匹配，就返回行，mysql不支持，使用leftjoin和union和rightjoin联合使用#select A.id as a_id,B.id as b_id,A.val as a_val,B.val as b_val from A left join B on A.id=B.id# union select A.id as a_id,B.id as b_id,A.val as a_val,B.val as b_val from A right join B on A.id=B.id#        1   1    ab   ab#        2  null  a   null#      null  3   null  ab#缓存：#为什么使用缓存？#缓解关系数据库并发访问的压力：热点数据#减少响应时间：内存IO比磁盘快#提升吞吐量：Redis等内存数据库单机就可以支撑很大并发#请简述Redis常用数据类型和使用场景？#String：用来实现简单的KV键值对存储，比如计数器#list：实现双向链表，比如用户的关注，粉丝列表#Hash：用来存储彼此相关信息的键值对#Set：存储不重复元素，比如用户的关注者#Sorted Set：实时信息排行榜#延伸考点：Redis内置实现。对于中高级，需要了解Redis各种类型的C底层实现方式#String：整数或者sds（Simple Dynamic String）#List：ziplist或者double linked list双端链表#Hash：ziplist或者hashtable#Set：intset或者hashtable#SortedSet：skiplist跳跃表#<<Redis设计于实现>>#Redis有哪些持久化方式#快照方式：把数据快照放在磁盘二进制文件中，dump.rdb#AOF：append Only File，每一个写命令追加到appendonly.aof中#Redis事务：#和Mysql事务有什么不同#将多个请求打包，一次性，按序执行多个命令的机制#Redis通过MULTI，EXE，WATCH等命令实现事务机制#Python redis-py，pipeline=conn.pipeline(transation=True)#Redis如何实现分布式锁？#kv键值对，有线程使用时，加一个kv键值对，没有线程使用资源时，就空#思路：# 1。使用setnx实现加锁，可以同时通过expire添加超时时间# 2。锁的value值可以使用一个随机的uuid或者特定的命名# 3。释放锁的时候，通过uuid判断是否是该锁，是则执行delete释放锁#使用缓存的模式？#Cashe Aside：同时更新缓存和数据库#Read/Write Through：先更新缓存，缓存负责同步更新数据库（比较少）#Write Behind Caching：先更新缓存，缓存定期异步更新数据库（比较少）#数据库和缓存之间的一致性##如何解决缓存穿透问题？#大量查询不到的数据的请求落到后端数据库，数据库压力增大#解决：对于没查到返回为None的数据也缓存，#  插入数据的时候删除相应缓存，或者设置较短的超时时间##如何解决缓存击穿问题？#非常热点的数据key过期，大量请求打到数据库#解决：1。分布式锁：获取锁的线程从数据库拉数据更新缓存，其他线程等待#2。异步后台更新：后台任务针对过期的key自动刷新#如何解决缓存雪崩问题？#缓存不可用或者大量缓存key同时失效，大量请求打到数据库#解决：1。多级缓存：不同级别的key设置不同的超时时间#2。随机超时时间：key的超时时间随机设置，防止同时超时#3。架构层，提升系统可用性，监控，报警完善