##[i for i in range(1,10) if i%2==0]#(i for i in range(1,10) if i%2==0)#方括号改成园括号，返回一个生成器，节省内存####a=['a','b','c']b=[1,2,3]#d = {'a':1,'b':2,'c':3}d1 = {}for i in range(len(a)) :    d1[a[i]] = b[i]print(d1)d2 = {k:v for k,v in zip(a,b)}print(d2)#zip 入参:一个或多个可迭代对象；返回:元祖列表a=[1,2,3]b=[4,5,6]c=[4,5,6,7,8]zipped = zip(a,b)print(zipped)print(zip(*zipped))#ll = ['a', 'b', 'c', 'd', 'e', 'f']#列表元素以此相连print(zip(ll[:-1],ll[1:]))#filter(func,iterator)#func 也可以是lambda函数，iterator所有元素，通过func为True的元素返回，返回一个迭代对象aa = list(range(1,10))def func(a):    return a%2==0res = filter(lambda x:x>5,aa)print(res)print(list(res))res1 = filter(func,aa)print(res1)print(list(res1))#map(func,iterator)#iterator所有元素进行映射，返回一个迭代对象bb=[2,3,4,5,6,7,8,9,0]def funb(a):    return a+1print(list(map(funb,aa)))res2 = map(lambda x,y:x+y,aa,bb)print(res2)print(list(res2))#reduce(func,iterator)规约函数#func必须传入两个参数，reduce返回一个值；from functools import reducedef fund(a,b):    return a*bret1 = reduce(fund,aa)print(ret1)ret2 = reduce(lambda x,y:x+y,aa)print(ret2)