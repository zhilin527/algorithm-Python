# -*- coding: UTF-8 -*-#五种IO模型#*# Unix网络编程中提到了5种网络模型# 1。Blocking IO# 2。Nonblocking IO# 3。IO multiplexing# 两种不常用# 4。Signal Driven IO# 5。Asynchronous IO####如何提升并发能力# 常见的提升并发能力：#  多线程模式，#  多进程模式，线程进程创建太多，资源消耗太多；#  IO多路复用#什么是IO多路复用？# 操作系统提供的同时监听多个socket的机制#  为了实现高并发需要一种机制并发处理多个socket#  linux常见的是select/poll/epoll#  可以使用单线程单进程处理多个socket##系统IO有两个过程：1。wait for data -> 2。copy data from kernel to user#阻塞式IO 一直等两步都完成#IO多路复用，提供了select等linux系统调用，在1步结束后，就能返回return readable，# 且select能监听多个socket，使多个socket卡在wait for data这里，一旦有数据传过来，就有readable### *#import selectorsimport socketsel = selectors.DefaultSelector()def accept(sock, mask):    conn,addr = sock.accept()    print('accepted -> ',conn,'addr -> ',addr)    conn.setblocking(False)    sel.register(conn,selectors.EVENT_READ,read)def read(conn, mask):    data = conn.recv(1024)    if data:        print('echoing ',repr(data),' to ',conn)        conn.send(data)    else:        print('cloing',conn)        sel.unregister(conn)        conn.close()sock = socket.socket()sock.bind(('127.0.0.1',8888))sock.listen(100)sock.setblocking(False)sel.register(sock,selectors.EVENT_READ,accept)while True:    events = sel.select()    for key,mask in events:        callback = key.data        callback(key.fileobj,mask)