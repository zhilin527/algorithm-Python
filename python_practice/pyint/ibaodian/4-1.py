#常用内置数据结构#list，tuple///array，collections.namedtuple#dict，set/frozenset，collections.deque,collections.Counter,collections.OrderedDict#sorted,bisect,heapq,functools.lru_cache(LRU)import collectionsimport heapqdef print_str(a=None,b=None):    if a is not None and b is not None:        print(str(a)+str(b))    elif b is None:        print(a)Point = collections.namedtuple('Point','x,y')p1 = Point(x=1,y=2)print_str(p1.x)print_str(p1[1])print('=========collections.deque==========')de = collections.deque()de.append(1)print_str('de->',de)de.appendleft(0)print_str('de->',de)de.append(3)print_str('de->',de)print_str('de pop->',de.pop())print_str('de->',de)print_str('de popleft->',de.popleft())print_str('de->',de)print_str('==========collections.Counter==========')c = collections.Counter()c = collections.Counter('abcba')print_str('c->',c)print_str('c.a->',c['a'])print_str('c.most_common->',c.most_common())print_str('==========collections.OrderedDict==========')#OrderedDict() key是按插入顺序排序的od1 = collections.OrderedDict()od1.update(**dict(b=1,a=2,c=3))print_str('od1->',od1)od2 = collections.OrderedDict()od2['b']=1od2['a']=2od2['c']=3print_str('od2->',od2)print_str('=========collections.defaultDict============')dd1 = collections.defaultdict(int)print_str(dd1.get('a'))print_str(dd1['a'])print_str('=========Python dict底层结构============')print_str('=========dict使用哈希表============')#为了支持快速查找使用了哈希表作为底层结构#哈希表平均查找时间复杂度O(1)#CPython使用二次探查法解决哈希冲突print_str('=========LRU算法实现============')class LRUcache(object):    def __init__(self,capacity=128):        self.capacity = capacity;        self.od = collections.OrderedDict()    def get(self,key):#最近访问的置于末尾        if key in self.od:            self.od.move_to_end(key)            return self.od[key]        else:            return -1    def put(self,key,value):#insert，并将最近的置于末尾，若满，则将前面的pop        if key in self.od:            del self.od[key]            self.od[key]=value        else:            self.od[key]=value            if len(self.od)>self.capacity:                self.od.popitem(last=False)if __name__ == '__main__':    def quicksort(arr):        if len(arr)<=1:            return arr        else:            pivot_index = 0            pivot = arr[pivot_index]            left_arr = [v for v in arr[pivot_index+1:] if v<=pivot]            right_arr = [v for v in arr[pivot_index+1:] if v>pivot]            return quicksort(left_arr)+[pivot]+quicksort(right_arr)    def bubleSort(arr,l,r):        for i in range(r,0,-1):            for j in range(0,i):                if arr[j]>arr[j+1]:                    tmp=arr[j]                    arr[j]=arr[j+1]                    arr[j+1]=tmp        return arr    def selectSort(arr):        for i in range(0,len(arr)):            minindx = i            for j in range(i+1,len(arr)):                if arr[j]<arr[i]:                    tmp=arr[i]                    arr[i]=arr[j]                    arr[j]=tmp        return arr    def insertSort(arr):        for i in range(1,len(arr)):            for j in range(i,0,-1):                if arr[j]<arr[j-1]:                    tmp=arr[j]                    arr[j]=arr[j-1]                    arr[j-1]=tmp        return arr    def heapSort(arr):        import heapq        items=[]        for v in arr:            heapq.heappush(items,v)        return [heapq.heappop(items) for i in range(len(items))]    def merge(arr1,arr2):        i,j=0,0        result = []        while i<len(arr1) and j<len(arr2):            if arr1[i]<=arr2[j]:                result.append(arr1[i])                i+=1            else:                result.append(arr2[j])                j+=1        result.extend(arr2[j:])        result.extend(arr1[i:])        return result    def mergeSort(arr,l,r):        mid = (l+r)//2        if len(arr)<2:            return arr        else:            left = mergeSort(arr[0:mid],0,mid)            right = mergeSort(arr[mid:],mid,r)            return merge(left,right)    def binary_search(arr,value):        l = 0        r = len(arr)        if not arr:            return -1        while l<r:            mid = (l+r)//2            if arr[mid] == value:                return mid            elif arr[mid]<value:                l=mid+1            elif arr[mid]>value:                r=mid-1        if l>=r:            return -1    arr1=[9,2,5,1,29,42]    # print(mergeSort(arr1,0,len(arr1)))    arr2 = [1,4,6,9,123,325]    # print(merge(arr1,arr2))    # print(binary_search(arr2,4))    class ListNode():        '''        定义节点类        data:数据        next:下一个数据        '''        def __init__(self, data, next=None):            self.data = data            self.next = next        def __repr__(self):            '''            用来定义Node的字节输出            '''            return str(self.data)    class ChainTable(ListNode):        '''        定义链表        '''        def __init__(self):            self.head = None            self.length = 0        def isEmpty(self):            return self.length==0        def add(self,dataOrnode):            if isinstance(dataOrnode,ListNode):                item = dataOrnode            else:                item = ListNode(dataOrnode)            if not self.head:                self.head = item                self.length +=1            else:                node = self.head                while node.next:                    node=node.next                node.next=item                self.length+=1        def reverse(self):            pre = None            node = self.head            while node:                next_node = node.next                node.next = pre                pre = node                node = next_node            self.head = pre        def delete(self,index):            if index<0 or index>self.length:                return -1            if self.isEmpty():                return -1            if index==0:                self.head = self.head.next                self.length-=1                return            j=0            prenode=self.head            cur=self.head            while cur.next and j<index:                prenode = cur                cur = cur.next                j+=1            if j==index:                prenode.next = cur.next                self.length-=1    ln = ChainTable()    ln.add(ListNode(2))    ln.add(ListNode(1))    ln.add(ListNode(3))    ln.reverse()    ln.delete(1)    node = ln.head    while node:        print(node)        node = node.next    # print(ln)    print('==================')    class Stack():        def __init__(self):            self.items = collections.deque()            self.minList = []        def pop(self):            self.minList.pop()            return  self.items.pop()        def push(self,val):            if not self.minList:                self.minList.append(val)            else:                if val<self.minList[-1]:                    self.minList.append(val)                else:                    self.minList.append(self.minList[-1])            self.items.append(val)        def isEmpty(self):            return len(self.items) == 0        def getMin(self):            return self.minList[-1]    class Queue_on_stack():        def __init__(self):            self.stack1 = Stack()            self.stack2 = Stack()        def push(self,val):            self.stack1.push(val)        def pop(self):            while not self.stack1.isEmpty():                self.stack2.push(self.stack2.pop())            if not self.stack2:                result = self.stack2.pop()            while not self.stack2.isEmpty():                self.stack1.push(self.stack2.pop())            return result        def isEmpty(self):            return self.stack1.isEmpty()    class topK():        def __init__(self,iterable,k):            self.iterable = iterable            self.capacity = k            self.minheap = []        def push(self,val):            if len(self.minheap)<self.capacity:                heapq.heappush(self.minheap,val)            else:                if val < self.minheap[0]:                    pass                else:                    heapq.heapreplace(self.minheap,val)        def get_top(self):            for v in self.iterable:                self.push(v)            return self.minheap    stack = Stack()    stack.push(1)    stack.push(2)    stack.push(3)    print(stack.getMin())    print(stack.pop())    print(stack.pop())    print(stack.getMin())    print(stack.items)